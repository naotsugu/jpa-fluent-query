== How to use Querying

`Querying` is used to construct the query.

[source, java]
----
List<Issue> issues = Querying.of(IssueModel.root())
    .filter(issue -> issue.getProject().getName().eq("name"))
    .toList().on(em);
----

The above is the same as below.

[source, java]
----
CriteriaBuilder builder = em.getCriteriaBuilder());
CriteriaQuery<Issue> query = builder.createQuery(Issue.class);
query.distinct(true);
Root<Issue> root = query.from(Issue.class);
query.select(root);
query.where(builder.equal(root.get(Issue_.project).get(Project_.name), "name"));
query.orderBy(builder().asc(root.get(Issue_.id)));
List<Issue> issues = em.createQuery(query).getResultList();
----

In `Querying`, distinct and sorting by ID is applied by default.

The following methods are available in `Querying`.

* `Querying<E, R, E> of(RootSource<E, R> rootSource)`
* `Querying<E, R, U> filter(Filter<E, R> filter)`
* `Querying<E, R, U> sorted(Sort<E, R> sort, ...)`
* `Querying<E, R, U> distinct()`
* `Querying<E, R, U> unDistinct()`
* `<Y> Querying<E, R, Y> map(Mapper<E, R, Y> mapper)`


=== Querying.of()

Querying can be instantiated by model classes generated by `JPA Fluent Modelgen`.

[source, java]
----
Querying.of(IssueModel.root())
----

In this example, `IssueModel.root()` is used to set the Issue entity as root.


=== Filter

Use `filter()` to filter the search results.

[source, java]
----
Querying.of(IssueModel.root())
  .filter(issue -> issue.getProject().getName().eq("..."))
----

The filter argument defines a predicate with a lambda whose root is the specified model.

To specify multiple conditions, filters can be specified consecutively.

[source, java]
----
Querying.of(IssueModel.root())
  .filter(issue -> issue.getProject().getName().eq("..."))
  .filter(issue -> issue.getTitle().like("..."))
----

By compositing with the Filters utility, it can also be written as follows.

[source, java]
----
import static com.mammb.code.jpa.fluent.query.Filters.*;

Querying.of(IssueModel.root())
.filter(issue -> and(
    issue.getProject().getName().eq("..."),
    issue.getTitle().like("..."))
----

Similarly, you can use an `Filters.or()`.

[source, java]
----
import static com.mammb.code.jpa.fluent.query.Filters.*;

Querying.of(IssueModel.root())
  .filter(issue -> {
      var tags = issue.joinTags();
      return or(
          tags.getName().eq("...").not(),
          tags.getLastModifiedOn().ge(LocalDateTime.of(1999, 1, 1, 1, 0)));
  })
----

Predefined filters can also be used.

[source, java]
----
Filter<Issue, IssueModel.Root_> filter = and(
    issue -> issue.getTitle().like("..."),
    issue -> issue.getDescription().eq("..."),
    issue -> issue.getProject().getState().in(PLAN, OPEN));

var issues = Querying.of(IssueModel.root())
  .filter(filter).toList().on(em);
----

[NOTE]
====
There are two ways to get the relationship between entities. +
`issue.getProject()` is equivalent to `root.get(Issue_.project)` in JPA. +
`issue.joinProject()` is equivalent to `root.join(Issue_.project)` in JPA.
====



=== Sorted

Use `sorted()` to ORDER BY clause.

If you do not specify a sort as follows

[source, java]
----
List<Issue> issues = Querying.of(IssueModel.root())
    .toList().on(em);
----

The following SQL will be used.

[source, sql]
----
SELECT ID, ... FROM ISSUE ORDER BY ID ASC
----

That is, sorting by ID is already applied by default.
This helps to make the resulting sequence unique.


To explicitly specify sorting, uses as follows

[source, java]
----
Querying.of(IssueModel.root())
    .sorted(issue -> issue.getProject().getName().desc(),
            issue -> issue.getTitle().asc())
----

The following `Order By` clause will be generated

[source, sql]
----
... ORDER BY PROJECT.NAME DESC, ISSUE.TITLE ASC, ISSUE.ID ASC
----

Sorting by ID is again given at the end.


[NOTE]
====
Sorting by ID is **not** automatically applied when using `map` or `SubQuery`.
====


=== Distinct

Queries by `Querying` are treated as `query.distinct(true)` by default.

This prevents the query result from being treated as an undesired direct product by joins.

If you want to explicitly use `query.distinct(false)`, you can use `unDistinct()`.

[source, java]
----
Querying.of(IssueModel.root())
    .filter(issue -> issue.getProject().getName().eq("..."))
    .unDistinct()
    .toList().on(em);
----

[NOTE]
====
As with sorting by ID, the automatic application of distinct does not apply to `map` and `SubQuery`.
You must use `distinct()` explicitly to get results with distinct.
====


=== Map

Use `map()` if you want to map query results to different types.

[source, java]
----
Optional<Integer> result = Querying.of(IssueModel.root())
  .filter(r -> r.getTitle().eq("..."))
  .map(Integer.class, issue -> issue.getPriority().max())
  .toOptional().on(em);
----

In this example, the result of the aggregate function is obtained as an `Integer`.


In addition to the predefined types, you can handle arbitrary result types by annotating them with `@Mappable`.

[source, java]
----
@Mappable
public record IssueDto(Long id, String title) { }
----

You can define a mapping to a DTO as follows

[source, java]
----
List<IssueDto> issues = Querying.of(IssueModel.root())
    .filter(...)
    .map(Mappers.issueDto(r -> r.getId(), r -> r.getTitle()))
    .toList().on(em);
----

The type and number of arguments can be detected at build time.


== How to use SubQuery

If you need a subquery, use `SubQuery`.

[source, java]
----
Querying.of(IssueModel.root())
    .filter(issue -> SubQuery.of(ProjectModel.root())
                             .filter(...)
                             .filter(prj -> prj.getId().eq(issue.getProject().getId()))
                             .exists())
    .toList().on(em);
----


You can also use `to()` to specify the result type of a subquery to compare as an Expression.

[source, java]
----
Querying.of(IssueModel.root())
    .filter(issue -> issue.getId().gt(
            SubQuery.of(ProjectModel.root())
                       .filter(prj -> prj.getName().eq("name1"))
                       .to(Long.class, prj -> prj.getId())))
    .toList().on(em);
----


The Correlated subquery should be as follows.

[source, java]
----
Querying.of(IssueModel.root())
    .filter(issue -> SubQuery.of(ProjectModel.root())
            .filter(...)
            .filter(issue, (issue1, prj) -> issue1.getProject().eq(prj))
            .exists())
    .toList().on(em);
----

[WARNING]
====
The above will not work because Hibernate does not currently handle `correlat` correctly.
====


== Querying with Request

Querying can use the `Request` class to retrieve results.

[source, java]
----
var request = new IssueRequest();
Page<Issue> issues = Querying.of(IssueModel.root()).toPage(request).on(em);
----


The request class is prepared by implementing the following interface.

* `Request` is a request that does not require paging
* `SliceRequest` is a request that requires paging

Create a class implementing `SliceRequest` as follows.


[source, java]
----
private static class IssueRequest implements SliceRequest<Issue, IssueModel.Root_> {
    public String title;
    @Override
    public Filter<Issue, IssueModel.Root_> getFilter() {
        return issue -> issue.getTitle().eq(title);
    }
}
----

You can use `IssueRequest` and get the following results.

[source, java]
----
var request = new IssueRequest();
request.title = "...";
Page<Issue> issues = Querying.of(IssueModel.root()).toPage(request).on(em);
----


== Result type of Querying

=== Typical result types

The results from `Querying` can be specified as follows

* `Query<Long> count()`
* `Query<Optional<U>> toOptional()`
* `Query<U> toSingle()`
* `Query<List<U>> toList()`
* `Query<Slice<U>> toSlice(SlicePoint slicePoint)`
* `Query<Page<U>> toPage(SlicePoint slicePoint)`


For each result type, there is also a method that takes `Request` as an argument, as described above.


=== Streaming result types

Uses for retrieving results on a page-by-page basis include.

* `Query<Stream<U>> toStream()`
* `Query<Stream<U>> toStream(int pageSize)`
* `Query<Stream<U>> toForwardingStream()`
* `Query<Stream<U>> toForwardingStream(int pageSize)`
* `Query<Iterable<U>> toIterable()`
* `Query<Iterable<U>> toIterable(int pageSize)`
* `Query<Iterable<U>> toForwardingIterable()`
* `Query<Iterable<U>> toForwardingIterable(int pageSize)`

Each result is sorted in ascending order by ID, and data is retrieved in order from the tail.

If you want to get the IDs in order from the smallest to the largest, use `toForwardingXXX`. Note, however, that there is a possibility of missing data if the data is updated at the same time.

For each result type, there is also a method that takes `Request` as an argument, as described above.



== More about Query


=== MapJoin

If you have a relationship by map, then the

[source, java]
----
@Entity
public class Project {

    @OneToMany
    Map<String, Task> tasks;
    // ...
}
----

You can handle MapJoin in the following way

[source, java]
----
Querying.of(ProjectModel.root())
    .filter(issue -> issue.joinTasks((k, v) -> k.like("...")))
    .toList().on(em);
----


=== Inheritance cast

Given the following inheritance relationship Entity

[source, java]
----
@Entity
public class Project extends BaseEntity {
    // ...
}

@Entity
public class ExternalProject extends Project {

}
----

It can be cast by using `asExternalProject()` as follows

[source, java]
----
Querying.of(IssueModel.root())
    .filter(issue -> issue.getProject().asExternalProject().getCode().eq("..."))
    .toList().on(em);
----

If there is an inheritance relationship Entity, a method like `asExternalProject()` is generated.
This works as a `criteriaBuilder.treat()` in JPA.




