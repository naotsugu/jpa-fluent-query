== Quick Start

=== Getting Started

If you use Gradle Kotlin DSL, define annotation processors and `jpa-fluent-query` dependencies as follows :

[source, kotlin]
----
dependencies {
  annotationProcessor("org.hibernate.orm:hibernate-jpamodelgen:6.1.0.Final") // <1>
  annotationProcessor("com.mammb:jpa-fluent-modelgen:0.6.0") // <2>
  implementation("com.mammb:jpa-fluent-query:0.6.0") // <3>
}
----
<1> jpa static metamodel generator. In this example we will use hibernate-jpamodelgen, but other model processors can be used.
<2> To generate APIs for queries from static metamodel classes
<3> Contains a fluent API for query construction

If you are using Groovy DSL, then use fallowing

[source, groovy]
----
dependencies {
  annotationProcessor 'org.hibernate.orm:hibernate-jpamodelgen:6.1.0.Final'
  annotationProcessor 'com.mammb:jpa-fluent-modelgen:0.6.0'
  implementation 'com.mammb:jpa-fluent-query:0.6.0'
}
----

In Maven, use the following

[source, xml]
----
  <dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-jpamodelgen</artifactId>
    <version>6.1.0.Final</version>
    <optional>true</optional>
  </dependency>
  <dependency>
    <groupId>com.mammb</groupId>
    <artifactId>jpa-fluent-modelgen</artifactId>
    <version>0.6.0</version>
    <optional>true</optional>
  </dependency>
  <dependency>
    <groupId>com.mammb</groupId>
    <artifactId>jpa-fluent-query</artifactId>
    <version>0.6.0</version>
  </dependency>
----


=== Building Queries

If you have an Issue entity like the following

[source, java]
----
@Entity
public class Issue extends BaseEntity {
  @ManyToOne
  private Project project;
  private String title;
  // ...
}
----

You can get the issue list as follows

[source, java]
----
@Transactional
@RequestScoped
public class IssueService {

  @PersistenceContext
  private EntityManager em;

  public List<Issue> findIssues(String name) {
    return Querying.of(IssueModel.root())
        .filter(issue -> issue.getProject().getName().eq(name))
        .toList().on(em);
  }
}
----

=== Count Query

The count of records can be obtained as follows

[source, java]
----
var count = Querying.of(IssueModel.root())
    .filter(issue -> issue.getTitle().eq("foo"))
    .count().on(em);
----


=== Order By Query

Order By specifies `sorted()` as follows.

[source, java]
----
List<Issue> issues = Querying.of(IssueModel.root())
    .filter(issue -> issue.getTitle().eq("foo"))
    .sorted(issue -> issue.getProject().getName().desc(),
            issue -> issue.getId().asc())
    .toList().on(em);
----


=== Paging Query

If paging is required, the following can be done

[source, java]
----
Page<Issue> page = Querying.of(IssueModel.root())
    .filter(issue -> issue.getTitle().eq("foo"))
    .toPage(SlicePoint.of()).on(em);
----

The query results can be obtained from the retrieved page as follows

[source, java]
----
int pageCount = page.getTotalPages();
long totalElements = page.getTotalElements();
List<Issue> issues = page.getContent();
----

Note that the default page size is 15 results.


=== Slicing Query

If you do not need the total number of records, you can use `Slice` instead of `Page`.

[source, java]
----
Slice<Issue> slice = Querying.of(IssueModel.root())
    .filter(issue -> issue.getTitle().eq("foo"))
    .toSlice(SlicePoint.of()).on(em);
----

The query results can be obtained from the retrieved slice as follows

[source, java]
----
List<Issue> issues = slice.getContent();
boolean hasNext = slice.hasNext();
----



=== Subquery

If a subquery is needed, use `SubQuery` as follows

[source, java]
----
List<Issue> issues = Querying.of(IssueModel.root())
    .filter(issue -> SubQuery.of(ProjectModel.root())
                             .filter(prj -> prj.getName().eq("name1"))
                             .filter(prj -> prj.getId().eq(issue.getProject().getId()))
                             .exists())
    .toList().on(em);
----




== Using Repository

For entities, the base class of the repository is automatically generated by the annotation processor.

A repository can be created as follows

[source, java]
----
public class IssueRepository implements IssueRepository_ {

  @Inject
  private EntityManager em;

  @Override
  public EntityManager em() {
      return em;
  }
}
----

Using the predefined methods, you can retrieve the listings as follows

[source, java]
----
var list = repository.findAll(issue -> issue.getProject().getName().eq("name"));
----


== Using typesafe mapping

If you use constructor expressions to map query results to DTOs, mapping errors can only be detected at run-time.

This library automatically creates a type-safe method for mapping by preparing a DTO annotated with `@Mappable` as follows.

[source, java]
----
@Mappable
public record IssueDto(Long id, String title) { }
----

Mapping to DTOs is done as follows

[source, java]
----
List<IssueDto> issues = Querying.of(IssueModel.root())
    .map(Mappers.issueDto(r -> r.getId(), r -> r.getTitle()))
    .toList().on(em);
----

The type and number of arguments can be detected at build time.




