== Quick Start

=== Getting Started

If you use Gradle Kotlin DSL, define annotation processors and `jpa-fluent-query` dependencies as follows :

[source, kotlin]
----
dependencies {
  annotationProcessor("org.hibernate.orm:hibernate-jpamodelgen:6.1.0.Final") // <1>
  annotationProcessor("com.mammb:jpa-fluent-modelgen:0.7.0") // <2>
  implementation("com.mammb:jpa-fluent-query:0.7.0") // <3>
}
----
<1> jpa static metamodel generator. In this example we will use hibernate-jpamodelgen, but other model processors can be used.
<2> To generate APIs for queries from static metamodel classes
<3> Contains a fluent API for query construction

If you are using Groovy DSL, then use fallowing

[source, groovy]
----
dependencies {
  annotationProcessor 'org.hibernate.orm:hibernate-jpamodelgen:6.1.0.Final'
  annotationProcessor 'com.mammb:jpa-fluent-modelgen:0.7.0'
  implementation 'com.mammb:jpa-fluent-query:0.7.0'
}
----

In Maven, use the following

[source, xml]
----
  <dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-jpamodelgen</artifactId>
    <version>6.1.0.Final</version>
    <optional>true</optional>
  </dependency>
  <dependency>
    <groupId>com.mammb</groupId>
    <artifactId>jpa-fluent-modelgen</artifactId>
    <version>0.7.0</version>
    <optional>true</optional>
  </dependency>
  <dependency>
    <groupId>com.mammb</groupId>
    <artifactId>jpa-fluent-query</artifactId>
    <version>0.7.0</version>
  </dependency>
----


=== Building Queries

If you have an Issue entity like the following

[source, java]
----
@Entity
public class Issue extends BaseEntity {

  private String title;

  @ManyToOne
  private Project project;

  // ...

}
----

You can get the issue list as follows

[source, java]
----
@Transactional
@RequestScoped
public class IssueService {

  @PersistenceContext
  private EntityManager em;

  public List<Issue> findIssues(String name) {

    return Querying.of(IssueModel.root())  // <1>
        .filter(issue -> issue.getProject().getName().eq(name)) // <2>
        .toList().on(em); // <3>

  }
}
----
<1> `IssueModel` is a model class generated by the annotation processor
<2> `Querying` generated from `IssueModel` can be filtered by predicates rooted at the Issue entity.
<3> Execute the query on the `EntityManager`, specifying the result type of the generated query.




=== Count Query

The count of records can be obtained as follows

[source, java]
----
var count = Querying.of(IssueModel.root())
    .filter(issue -> issue.getTitle().eq("foo"))
    .count().on(em);
----


=== Order By Query

Order By specifies `sorted()` as follows.

[source, java]
----
List<Issue> issues = Querying.of(IssueModel.root())
    .filter(issue -> issue.getTitle().eq("foo"))
    .sorted(issue -> issue.getProject().getName().desc(),
            issue -> issue.getId().asc())
    .toList().on(em);
----


=== Paging Query

If paging is required, the following can be done

[source, java]
----
Page<Issue> page = Querying.of(IssueModel.root())
    .filter(issue -> issue.getTitle().eq("foo"))
    .toPage(SlicePoint.of()).on(em);
----

The query results can be obtained from the retrieved page as follows

[source, java]
----
int pageCount = page.getTotalPages();
long totalElements = page.getTotalElements();
List<Issue> issues = page.getContent();
----

Note that the default page size is 15 results.


=== Slicing Query

If you do not need the total number of records, you can use `Slice` instead of `Page`.

[source, java]
----
Slice<Issue> slice = Querying.of(IssueModel.root())
    .filter(issue -> issue.getTitle().eq("foo"))
    .toSlice(SlicePoint.of()).on(em);
----

The query results can be obtained from the retrieved slice as follows

[source, java]
----
List<Issue> issues = slice.getContent();
boolean hasNext = slice.hasNext();
----



=== Stream Query

A Stream can be obtained by `toStream()`.

[source, java]
----
Stream<Issue> issues = Querying.of(IssueModel.root())
        .filter(issue -> issue.getProject().getName().eq("name"))
        .toStream().on(em);
----

The Stream retrieved here retrieves a record each time on a page(by default, every 100 records per page).

Similarly, it can be obtained as an `Iterable` with `toIterable()`.

[source, java]
----
Iterable<Issue> issues = Querying.of(IssueModel.root())
        .filter(issue -> issue.getProject().getName().eq("name"))
        .toIterable().on(em);
----



=== Subquery

If a subquery is needed, use `SubQuery` as follows

[source, java]
----
List<Issue> issues = Querying.of(IssueModel.root())
    .filter(issue -> SubQuery.of(ProjectModel.root())
                             .filter(prj -> prj.getName().eq("name1"))
                             .filter(prj -> prj.getId().eq(issue.getProject().getId()))
                             .exists())
    .toList().on(em);
----




=== Using Repository

For entities, the base class of the repository is automatically generated by the annotation processor.

To use the repository, you must first prepare a interface annotated with `@RepositoryTrait` as follows to select a Trait to Mixin to the repository.

[source, java]
----
@RepositoryTrait
public interface BaseRepository<PK extends Serializable, E, R extends RootAware<E>>
    extends QueryRepository<PK, E, R>, CommandRepository<PK, E> {
}
----


A repository can be created as follows

[source, java]
----
public class IssueRepository implements IssueRepository_ {

  @Inject
  private EntityManager em;

  @Override
  public EntityManager em() {
      return em;
  }
}
----

`IssueRepository_` implements `BaseRepository`.

The default methods provided by the `QueryRepository` and `CommandRepository` will be available.

Using the predefined methods, you can retrieve the listings as follows

[source, java]
----
var list = repository.findAll(issue -> issue.getProject().getName().eq("name"));
----

The following methods are predefined.

* `List<E> findAll(...)`
* `Page<E> findPage(...)`
* `Slice<E> findSlice(...)`
* `long count(...)`
* `E get(E entity)`
* `Optional<E> get(PK id)`
* `Optional<E> getReference(PK id)`
* `E save(E entity)`
* `E saveAndFlash(E entity)`
* `void delete(E entity)`
* `void deleteAndFlash(E entity)`




=== Using typesafe mapping

If you use constructor expressions to map query results to DTOs, mapping errors can only be detected at run-time.

This library automatically creates a type-safe method for mapping by preparing a DTO annotated with `@Mappable` as follows.

[source, java]
----
@Mappable
public record IssueDto(Long id, String title) { }
----

If a class in which `@Mappable` is defined exists, the following methods are automatically generated according to the constructor of the class.


[source, java]
----
@Generated(value = "com.mammb.code.jpa.fluent.modelgen.JpaModelProcessor")
public abstract class Mappers {

    public static <E, R extends RootAware<E>> Mapper<E, R, IssueDto> issueDto(
            Criteria.Selector<E, R, Long> e1, Criteria.Selector<E, R, String> e2) {
        return Mapper.construct(IssueDto.class, Arrays.asList(Selector.of(e1), Selector.of(e2)), Grouping.empty());
    }

    // ...
}
----


Using `Mappers` methods, the mapping to DTOs is done as follows

[source, java]
----
List<IssueDto> issues = Querying.of(IssueModel.root())
    .map(Mappers.issueDto(r -> r.getId(), r -> r.getTitle()))
    .toList().on(em);
----

The type and number of arguments can be detected at build time.




